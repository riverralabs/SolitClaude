<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Perfect Solitaire - Vintage Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Cinzel:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background:
                radial-gradient(ellipse at center, #1a3d1a 0%, #0d260d 50%, #081408 100%);
            min-height: 100vh;
            font-family: 'Cinzel', 'Times New Roman', serif;
            overflow: hidden;
        }

        /* Felt texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,0.03) 2px,
                    rgba(0,0,0,0.03) 4px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 2px,
                    rgba(0,0,0,0.03) 2px,
                    rgba(0,0,0,0.03) 4px
                );
            pointer-events: none;
            z-index: 1;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        /* Vintage Controls */
        .controls {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
            flex-wrap: wrap;
            justify-content: center;
            padding: 12px 20px;
            background: linear-gradient(180deg, #3d2817 0%, #2a1a0f 50%, #1f140a 100%);
            border: 3px solid #5c3d2e;
            border-radius: 8px;
            box-shadow:
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.3),
                0 4px 15px rgba(0,0,0,0.5),
                0 0 0 1px rgba(0,0,0,0.3);
        }

        .vintage-btn {
            background: linear-gradient(180deg, #8b6914 0%, #6b4f0f 50%, #4a370a 100%);
            border: 2px solid #a67c00;
            border-radius: 4px;
            padding: 8px 16px;
            color: #f5e6c8;
            font-size: 13px;
            font-weight: 700;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.15s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            box-shadow:
                inset 0 1px 0 rgba(255,255,255,0.2),
                inset 0 -1px 0 rgba(0,0,0,0.3),
                0 2px 4px rgba(0,0,0,0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .vintage-btn:hover {
            background: linear-gradient(180deg, #a67c00 0%, #8b6914 50%, #6b4f0f 100%);
            border-color: #d4a843;
            box-shadow:
                inset 0 1px 0 rgba(255,255,255,0.3),
                inset 0 -1px 0 rgba(0,0,0,0.3),
                0 3px 8px rgba(0,0,0,0.4),
                0 0 10px rgba(212, 168, 67, 0.3);
        }

        .vintage-btn:active {
            transform: translateY(1px);
            box-shadow:
                inset 0 1px 3px rgba(0,0,0,0.3),
                0 1px 2px rgba(0,0,0,0.3);
        }

        .vintage-btn.active {
            background: linear-gradient(180deg, #d4a843 0%, #a67c00 50%, #8b6914 100%);
            border-color: #f5d17a;
            color: #1a0f00;
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
        }

        .vintage-btn.hint-btn {
            background: linear-gradient(180deg, #2d5a3d 0%, #1e4028 50%, #142d1a 100%);
            border-color: #4a8b5c;
        }

        .vintage-btn.hint-btn:hover {
            background: linear-gradient(180deg, #3d7a52 0%, #2d5a3d 50%, #1e4028 100%);
            border-color: #6bab7c;
            box-shadow:
                inset 0 1px 0 rgba(255,255,255,0.3),
                inset 0 -1px 0 rgba(0,0,0,0.3),
                0 3px 8px rgba(0,0,0,0.4),
                0 0 10px rgba(107, 171, 124, 0.3);
        }

        .score-display {
            background: linear-gradient(180deg, #1a0f05 0%, #0d0805 100%);
            border: 2px solid #5c3d2e;
            border-radius: 4px;
            padding: 8px 16px;
            color: #d4a843;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Playfair Display', serif;
            text-shadow: 0 0 10px rgba(212, 168, 67, 0.5);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .suit-selector {
            display: flex;
            gap: 4px;
        }

        .suit-btn {
            padding: 8px 12px;
            min-width: 40px;
        }

        /* Win Screen - Vintage Style */
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(26, 15, 5, 0.95) 0%, rgba(0,0,0,0.98) 100%);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .trophy {
            font-size: 100px;
            animation: float 2s ease-in-out infinite;
            filter: drop-shadow(0 0 30px rgba(212, 168, 67, 0.8));
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(-2deg); }
            50% { transform: translateY(-15px) rotate(2deg); }
        }

        .win-text {
            color: #d4a843;
            font-size: 42px;
            font-weight: bold;
            font-family: 'Playfair Display', serif;
            margin-top: 20px;
            text-shadow:
                0 0 20px rgba(212, 168, 67, 0.8),
                0 2px 4px rgba(0,0,0,0.5);
            letter-spacing: 4px;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px rgba(212, 168, 67, 0.8), 0 2px 4px rgba(0,0,0,0.5); }
            50% { text-shadow: 0 0 40px rgba(212, 168, 67, 1), 0 0 60px rgba(212, 168, 67, 0.5), 0 2px 4px rgba(0,0,0,0.5); }
        }

        .win-score {
            color: #f5e6c8;
            font-size: 22px;
            margin-top: 15px;
            font-family: 'Cinzel', serif;
            letter-spacing: 2px;
        }

        .win-btn {
            margin-top: 30px;
            padding: 12px 35px;
            font-size: 16px;
        }

        /* Hint highlight overlay */
        .hint-pulse {
            animation: hintPulse 0.8s ease-in-out infinite;
        }

        @keyframes hintPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .vintage-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            .score-display {
                font-size: 12px;
                padding: 6px 10px;
            }
            .trophy {
                font-size: 70px;
            }
            .win-text {
                font-size: 28px;
            }
            .controls {
                padding: 8px 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="controls">
            <button class="vintage-btn" id="newGameBtn">New Game</button>
            <button class="vintage-btn" id="drawBtn">Draw</button>
            <button class="vintage-btn" id="undoBtn">Undo</button>
            <button class="vintage-btn hint-btn" id="hintBtn">Hint</button>
            <div class="suit-selector">
                <button class="vintage-btn suit-btn" data-suits="1">1</button>
                <button class="vintage-btn suit-btn" data-suits="2">2</button>
                <button class="vintage-btn suit-btn active" data-suits="4">4</button>
            </div>
            <div class="score-display">Score: <span id="scoreValue">0</span></div>
        </div>

        <div id="winScreen">
            <div class="trophy">&#127942;</div>
            <div class="win-text">VICTORY!</div>
            <div class="win-score">Final Score: <span id="finalScore">0</span></div>
            <button class="vintage-btn win-btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        // ============== CONFIGURATION ==============
        const CONFIG = {
            CARD_WIDTH: 70,
            CARD_HEIGHT: 100,
            CARD_RADIUS: 6,
            COLUMN_SPACING: 10,
            ROW_OFFSET: 25,
            STOCK_OFFSET: 3,
            MAX_PARTICLES: 200,
            GRAVITY: 0.4,
            FRICTION: 0.92,
            LERP_SPEED: 0.25,
            MAX_UNDO: 5,
            SUITS: ['♠', '♥', '♦', '♣'],
            SUIT_COLORS: { '♠': '#1a1a2e', '♥': '#8b1a1a', '♦': '#8b1a1a', '♣': '#1a1a2e' },
            RANKS: ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
            RANK_VALUES: { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 }
        };

        // ============== PARTICLE SYSTEM (Optimized) ==============
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1;
                this.decay = 0.03 + Math.random() * 0.02;

                if (type === 'trail') {
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = (Math.random() - 0.5) * 1.5;
                    this.size = 2 + Math.random() * 2;
                    this.color = `hsla(45, 80%, 50%, `;
                } else if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 6;
                    this.vy = -Math.random() * 8 - 4;
                    this.size = 2 + Math.random() * 3;
                    this.color = `hsla(${40 + Math.random() * 20}, 100%, 55%, `;
                } else if (type === 'confetti') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = -Math.random() * 12 - 4;
                    this.size = 4 + Math.random() * 4;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.2;
                    this.color = `hsla(${Math.random() * 60 + 20}, 90%, 55%, `;
                    this.decay = 0.008 + Math.random() * 0.005;
                } else if (type === 'hint') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = -Math.random() * 2 - 1;
                    this.size = 3 + Math.random() * 2;
                    this.color = `hsla(120, 80%, 60%, `;
                    this.decay = 0.04;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += CONFIG.GRAVITY * 0.25;
                this.vx *= 0.98;
                this.life -= this.decay;
                if (this.type === 'confetti') {
                    this.rotation += this.rotationSpeed;
                }
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color + this.life + ')';

                if (this.type === 'confetti') {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.fillRect(-this.size/2, -this.size/4, this.size, this.size/2);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.lastEmit = 0;
            }

            emit(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    if (this.particles.length < CONFIG.MAX_PARTICLES) {
                        this.particles.push(new Particle(x, y, type));
                    }
                }
            }

            // Throttled emit for drag trails
            emitThrottled(x, y, type, count = 1, throttleMs = 50) {
                const now = performance.now();
                if (now - this.lastEmit > throttleMs) {
                    this.emit(x, y, type, count);
                    this.lastEmit = now;
                }
            }

            update() {
                this.particles = this.particles.filter(p => p.update());
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }

            clear() {
                this.particles = [];
            }
        }

        // ============== CARD CLASS ==============
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = CONFIG.RANK_VALUES[rank];
                this.faceUp = false;
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.vx = 0;
                this.vy = 0;
                this.width = CONFIG.CARD_WIDTH;
                this.height = CONFIG.CARD_HEIGHT;
                this.dragging = false;
                this.hovered = false;
                this.highlighted = false;
                this.highlightColor = null;
                this.zIndex = 0;
            }

            get color() {
                return CONFIG.SUIT_COLORS[this.suit];
            }

            update() {
                if (!this.dragging) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;

                    // Smoother lerp with velocity damping
                    this.vx = dx * CONFIG.LERP_SPEED;
                    this.vy = dy * CONFIG.LERP_SPEED;

                    this.x += this.vx;
                    this.y += this.vy;

                    // Snap when very close
                    if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                        this.vx = 0;
                        this.vy = 0;
                    }
                }
            }

            draw(ctx) {
                ctx.save();

                // Shadow - reduced for better performance
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = this.dragging ? 15 : 8;
                ctx.shadowOffsetX = this.dragging ? 6 : 2;
                ctx.shadowOffsetY = this.dragging ? 6 : 2;

                // Card body
                ctx.beginPath();
                this.roundRect(ctx, this.x, this.y, this.width, this.height, CONFIG.CARD_RADIUS);

                if (this.faceUp) {
                    // Vintage cream card face
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                    gradient.addColorStop(0, '#faf6e9');
                    gradient.addColorStop(0.5, '#f5edd6');
                    gradient.addColorStop(1, '#ebe3c8');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Highlight effect for hints
                    if (this.highlighted) {
                        ctx.shadowColor = this.highlightColor || 'rgba(76, 175, 80, 0.8)';
                        ctx.shadowBlur = 20;
                        ctx.strokeStyle = this.highlightColor || '#4CAF50';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    // Hover glow - vintage gold
                    else if (this.hovered && !this.dragging) {
                        ctx.shadowColor = 'rgba(212, 168, 67, 0.6)';
                        ctx.shadowBlur = 12;
                        ctx.strokeStyle = 'rgba(212, 168, 67, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    ctx.shadowColor = 'transparent';

                    // Vintage border
                    ctx.strokeStyle = '#c4b896';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Inner border for vintage feel
                    ctx.strokeStyle = 'rgba(139, 105, 20, 0.3)';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    this.roundRect(ctx, this.x + 3, this.y + 3, this.width - 6, this.height - 6, CONFIG.CARD_RADIUS - 2);
                    ctx.stroke();

                    // Draw suit and rank - vintage style
                    ctx.fillStyle = this.color;
                    ctx.font = 'bold 15px "Playfair Display", Georgia, serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.rank, this.x + 5, this.y + 17);
                    ctx.font = '14px serif';
                    ctx.fillText(this.suit, this.x + 5, this.y + 32);

                    // Center suit - larger
                    ctx.font = 'bold 30px serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.suit, this.x + this.width/2, this.y + this.height/2 + 10);

                    // Bottom right (inverted)
                    ctx.font = 'bold 15px "Playfair Display", Georgia, serif';
                    ctx.textAlign = 'right';
                    ctx.fillText(this.rank, this.x + this.width - 5, this.y + this.height - 8);
                    ctx.font = '14px serif';
                    ctx.fillText(this.suit, this.x + this.width - 5, this.y + this.height - 22);
                } else {
                    // Vintage card back - rich burgundy/maroon
                    const backGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                    backGradient.addColorStop(0, '#5c1a1a');
                    backGradient.addColorStop(0.3, '#7a2828');
                    backGradient.addColorStop(0.5, '#8b3030');
                    backGradient.addColorStop(0.7, '#7a2828');
                    backGradient.addColorStop(1, '#5c1a1a');
                    ctx.fillStyle = backGradient;
                    ctx.fill();

                    ctx.strokeStyle = '#3d1010';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.shadowColor = 'transparent';

                    // Ornate border pattern
                    ctx.strokeStyle = 'rgba(212, 168, 67, 0.4)';
                    ctx.lineWidth = 1;
                    const padding = 6;
                    ctx.beginPath();
                    this.roundRect(ctx, this.x + padding, this.y + padding,
                                   this.width - padding * 2, this.height - padding * 2, 3);
                    ctx.stroke();

                    // Inner decorative pattern
                    ctx.strokeStyle = 'rgba(212, 168, 67, 0.25)';
                    ctx.beginPath();
                    this.roundRect(ctx, this.x + padding + 4, this.y + padding + 4,
                                   this.width - padding * 2 - 8, this.height - padding * 2 - 8, 2);
                    ctx.stroke();

                    // Center ornament - diamond pattern
                    ctx.fillStyle = 'rgba(212, 168, 67, 0.35)';
                    const cx = this.x + this.width/2;
                    const cy = this.y + this.height/2;

                    // Large diamond
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - 18);
                    ctx.lineTo(cx + 12, cy);
                    ctx.lineTo(cx, cy + 18);
                    ctx.lineTo(cx - 12, cy);
                    ctx.closePath();
                    ctx.fill();

                    // Small diamonds around
                    ctx.fillStyle = 'rgba(212, 168, 67, 0.25)';
                    const smallSize = 6;
                    [[0, -28], [0, 28], [-20, 0], [20, 0]].forEach(([ox, oy]) => {
                        ctx.beginPath();
                        ctx.moveTo(cx + ox, cy + oy - smallSize);
                        ctx.lineTo(cx + ox + smallSize/1.5, cy + oy);
                        ctx.lineTo(cx + ox, cy + oy + smallSize);
                        ctx.lineTo(cx + ox - smallSize/1.5, cy + oy);
                        ctx.closePath();
                        ctx.fill();
                    });
                }

                ctx.restore();
            }

            roundRect(ctx, x, y, w, h, r) {
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
            }

            contains(px, py) {
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            snapTo(x, y) {
                this.x = this.targetX = x;
                this.y = this.targetY = y;
                this.vx = 0;
                this.vy = 0;
            }
        }

        // ============== GAME CLASS ==============
        class PerfectSolitaire {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = new ParticleSystem();

                this.columns = [];
                this.stock = [];
                this.completed = [];
                this.draggedCards = [];
                this.dragStartColumn = -1;
                this.dragStartIndex = -1;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                this.score = 0;
                this.suitCount = 4;
                this.undoStack = [];
                this.hoveredCard = null;

                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.isDragging = false;

                // Hint system
                this.currentHint = null;
                this.hintTimeout = null;

                this.setupCanvas();
                this.setupEventListeners();
                this.loadGame() || this.newGame();
                this.gameLoop();
            }

            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.calculateLayout();
                };
                window.addEventListener('resize', resize);
                resize();
            }

            calculateLayout() {
                const totalWidth = 10 * CONFIG.CARD_WIDTH + 9 * CONFIG.COLUMN_SPACING;
                const availableWidth = this.canvas.width - 40;
                const scale = Math.min(1, availableWidth / totalWidth);

                this.cardWidth = CONFIG.CARD_WIDTH * scale;
                this.cardHeight = CONFIG.CARD_HEIGHT * scale;
                this.columnSpacing = CONFIG.COLUMN_SPACING * scale;
                this.rowOffset = CONFIG.ROW_OFFSET * scale;

                this.startX = (this.canvas.width - (10 * this.cardWidth + 9 * this.columnSpacing)) / 2;
                this.startY = 80;
                this.stockX = this.startX;
                this.stockY = this.canvas.height - this.cardHeight - 20;

                this.updateCardPositions();
            }

            setupEventListeners() {
                // Mouse events - optimized
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerDown(e.clientX, e.clientY));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e.clientX, e.clientY));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerUp(e.clientX, e.clientY));
                this.canvas.addEventListener('mouseleave', () => {
                    if (this.isDragging) this.handlePointerUp(this.lastMouseX, this.lastMouseY);
                });

                // Touch events - optimized
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerDown(touch.clientX, touch.clientY);
                }, { passive: false });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerMove(touch.clientX, touch.clientY);
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handlePointerUp(this.lastMouseX, this.lastMouseY);
                }, { passive: false });

                // Buttons
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('drawBtn').addEventListener('click', () => this.drawFromStock());
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    document.getElementById('winScreen').style.display = 'none';
                    this.newGame();
                });

                // Suit buttons
                document.querySelectorAll('.suit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.suit-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.suitCount = parseInt(btn.dataset.suits);
                        this.newGame();
                    });
                });
            }

            createDeck() {
                const deck = [];
                const decksNeeded = 2;
                const suitsToUse = CONFIG.SUITS.slice(0, this.suitCount);

                for (let d = 0; d < decksNeeded; d++) {
                    for (const suit of suitsToUse) {
                        const copies = Math.ceil(4 / this.suitCount);
                        for (let c = 0; c < copies; c++) {
                            for (const rank of CONFIG.RANKS) {
                                deck.push(new Card(suit, rank));
                            }
                        }
                    }
                }

                while (deck.length > 104) deck.pop();
                while (deck.length < 104) {
                    const suit = suitsToUse[Math.floor(Math.random() * suitsToUse.length)];
                    const rank = CONFIG.RANKS[Math.floor(Math.random() * CONFIG.RANKS.length)];
                    deck.push(new Card(suit, rank));
                }

                // Fisher-Yates shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                return deck;
            }

            newGame() {
                this.particles.clear();
                this.score = 0;
                this.undoStack = [];
                this.completed = [];
                this.draggedCards = [];
                this.clearHint();
                this.updateScore();

                const deck = this.createDeck();
                this.columns = [];

                let cardIndex = 0;
                for (let col = 0; col < 10; col++) {
                    const columnCards = [];
                    const cardCount = col < 4 ? 6 : 5;

                    for (let row = 0; row < cardCount; row++) {
                        const card = deck[cardIndex++];
                        card.faceUp = (row === cardCount - 1);
                        columnCards.push(card);
                    }
                    this.columns.push(columnCards);
                }

                this.stock = deck.slice(cardIndex);
                this.stock.forEach(card => card.faceUp = false);

                this.updateCardPositions();
                this.saveGame();
            }

            updateCardPositions() {
                for (let col = 0; col < this.columns.length; col++) {
                    const column = this.columns[col];
                    for (let row = 0; row < column.length; row++) {
                        const card = column[row];
                        if (!card.dragging) {
                            const x = this.startX + col * (this.cardWidth + this.columnSpacing);
                            const y = this.startY + row * this.rowOffset;
                            card.setTarget(x, y);
                            card.width = this.cardWidth;
                            card.height = this.cardHeight;
                            card.zIndex = row;
                        }
                    }
                }

                for (let i = 0; i < this.stock.length; i++) {
                    const card = this.stock[i];
                    card.setTarget(this.stockX + Math.min(i, 5) * CONFIG.STOCK_OFFSET, this.stockY);
                    card.width = this.cardWidth;
                    card.height = this.cardHeight;
                    card.zIndex = i;
                }
            }

            handlePointerDown(x, y) {
                this.clearHint();

                // Check stock click
                if (this.stock.length > 0) {
                    const topStock = this.stock[this.stock.length - 1];
                    if (topStock.contains(x, y)) {
                        this.drawFromStock();
                        return;
                    }
                }

                // Check columns
                for (let col = this.columns.length - 1; col >= 0; col--) {
                    const column = this.columns[col];
                    for (let row = column.length - 1; row >= 0; row--) {
                        const card = column[row];
                        if (card.faceUp && card.contains(x, y)) {
                            if (this.canDragStack(col, row)) {
                                this.startDrag(col, row, x, y);
                                return;
                            }
                        }
                    }
                }
            }

            canDragStack(col, startRow) {
                const column = this.columns[col];
                for (let i = startRow; i < column.length - 1; i++) {
                    if (!column[i].faceUp || column[i].value !== column[i + 1].value + 1) {
                        return false;
                    }
                }
                return true;
            }

            startDrag(col, row, x, y) {
                this.isDragging = true;
                this.dragStartColumn = col;
                this.dragStartIndex = row;

                const column = this.columns[col];
                this.draggedCards = column.splice(row);

                const firstCard = this.draggedCards[0];
                this.dragOffsetX = x - firstCard.x;
                this.dragOffsetY = y - firstCard.y;

                this.draggedCards.forEach((card, i) => {
                    card.dragging = true;
                    card.zIndex = 1000 + i;
                });
            }

            handlePointerMove(x, y) {
                this.lastMouseX = x;
                this.lastMouseY = y;

                if (this.isDragging && this.draggedCards.length > 0) {
                    // Emit sparse trail particles - much less frequent
                    this.particles.emitThrottled(x, y, 'trail', 1, 80);

                    // Direct position update - no velocity tracking during drag for smoothness
                    this.draggedCards.forEach((card, i) => {
                        card.x = x - this.dragOffsetX;
                        card.y = y - this.dragOffsetY + i * this.rowOffset;
                    });
                } else if (!this.isDragging) {
                    // Handle hover only when not dragging
                    this.hoveredCard = null;
                    for (const column of this.columns) {
                        for (const card of column) {
                            card.hovered = false;
                            if (card.faceUp && card.contains(x, y)) {
                                card.hovered = true;
                                this.hoveredCard = card;
                            }
                        }
                    }
                }
            }

            handlePointerUp(x, y) {
                if (!this.isDragging || this.draggedCards.length === 0) {
                    this.isDragging = false;
                    return;
                }

                this.isDragging = false;

                this.draggedCards.forEach(card => {
                    card.dragging = false;
                });

                // Find target column
                let targetCol = -1;
                let validMove = false;

                const firstDragged = this.draggedCards[0];

                for (let col = 0; col < 10; col++) {
                    const colX = this.startX + col * (this.cardWidth + this.columnSpacing);
                    if (x >= colX && x <= colX + this.cardWidth) {
                        targetCol = col;
                        break;
                    }
                }

                if (targetCol >= 0 && targetCol !== this.dragStartColumn) {
                    const targetColumn = this.columns[targetCol];

                    if (targetColumn.length === 0) {
                        validMove = true;
                    } else {
                        const topCard = targetColumn[targetColumn.length - 1];
                        if (topCard.faceUp && topCard.value === firstDragged.value + 1) {
                            validMove = true;
                        }
                    }
                }

                if (validMove) {
                    this.saveState();
                    this.columns[targetCol].push(...this.draggedCards);
                    this.revealTopCard(this.dragStartColumn);
                    this.addScore(this.draggedCards.length * 5);
                    this.checkSequenceComplete(targetCol);
                } else {
                    this.columns[this.dragStartColumn].push(...this.draggedCards);
                }

                this.draggedCards = [];
                this.updateCardPositions();
                this.saveGame();
            }

            revealTopCard(col) {
                const column = this.columns[col];
                if (column.length > 0 && !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    this.addScore(10);
                }
            }

            checkSequenceComplete(col) {
                const column = this.columns[col];
                if (column.length < 13) return;

                const lastIndex = column.length - 1;
                if (column[lastIndex].value !== 1) return;

                const suit = column[lastIndex].suit;
                let valid = true;

                for (let i = 0; i < 13; i++) {
                    const card = column[lastIndex - i];
                    if (!card.faceUp || card.suit !== suit || card.value !== i + 1) {
                        valid = false;
                        break;
                    }
                }

                if (valid) {
                    const removed = column.splice(column.length - 13);
                    this.completed.push(removed);

                    const centerX = this.startX + col * (this.cardWidth + this.columnSpacing) + this.cardWidth / 2;
                    const centerY = this.startY + (column.length + 6) * this.rowOffset;
                    for (let i = 0; i < 30; i++) {
                        this.particles.emit(centerX, centerY, 'spark', 1);
                    }

                    this.addScore(100);
                    this.revealTopCard(col);

                    if (this.completed.length === 8) {
                        this.win();
                    }
                }
            }

            drawFromStock() {
                const hasEmpty = this.columns.some(col => col.length === 0);
                if (hasEmpty) return;

                if (this.stock.length === 0) return;

                this.saveState();
                this.clearHint();

                for (let col = 0; col < 10 && this.stock.length > 0; col++) {
                    const card = this.stock.pop();
                    card.faceUp = true;
                    this.columns[col].push(card);
                }

                this.updateCardPositions();
                this.saveGame();
            }

            // ============== HINT SYSTEM ==============
            findHint() {
                const hints = [];

                // Priority 1: Find moves that complete a sequence
                for (let srcCol = 0; srcCol < 10; srcCol++) {
                    const srcColumn = this.columns[srcCol];
                    if (srcColumn.length === 0) continue;

                    for (let srcRow = 0; srcRow < srcColumn.length; srcRow++) {
                        const srcCard = srcColumn[srcRow];
                        if (!srcCard.faceUp) continue;
                        if (!this.canDragStack(srcCol, srcRow)) continue;

                        const stackSize = srcColumn.length - srcRow;

                        for (let destCol = 0; destCol < 10; destCol++) {
                            if (destCol === srcCol) continue;

                            const destColumn = this.columns[destCol];
                            let validMove = false;

                            if (destColumn.length === 0) {
                                validMove = true;
                            } else {
                                const destCard = destColumn[destColumn.length - 1];
                                if (destCard.faceUp && destCard.value === srcCard.value + 1) {
                                    validMove = true;
                                }
                            }

                            if (validMove) {
                                // Check if this creates a same-suit sequence
                                let sameSuitBonus = 0;
                                if (destColumn.length > 0) {
                                    const destCard = destColumn[destColumn.length - 1];
                                    if (destCard.suit === srcCard.suit) {
                                        sameSuitBonus = 10;

                                        // Check how long the same-suit sequence would be
                                        let seqLen = 1;
                                        for (let i = destColumn.length - 2; i >= 0; i--) {
                                            const c = destColumn[i];
                                            if (c.faceUp && c.suit === srcCard.suit &&
                                                c.value === destColumn[i + 1].value + 1) {
                                                seqLen++;
                                            } else break;
                                        }
                                        sameSuitBonus += seqLen * 2;
                                    }
                                }

                                // Check if source reveals a hidden card
                                let revealsCard = (srcRow > 0 && !srcColumn[srcRow - 1].faceUp) ? 5 : 0;

                                // Prefer moving Kings to empty columns
                                let kingToEmptyBonus = (srcCard.value === 13 && destColumn.length === 0 && srcRow > 0) ? 8 : 0;

                                // Don't move from empty to empty unnecessarily
                                if (srcColumn.length === stackSize && destColumn.length === 0) {
                                    continue;
                                }

                                hints.push({
                                    srcCol,
                                    srcRow,
                                    destCol,
                                    priority: sameSuitBonus + revealsCard + kingToEmptyBonus + stackSize,
                                    description: this.getHintDescription(srcCard, srcCol, destCol, destColumn)
                                });
                            }
                        }
                    }
                }

                // Sort by priority (highest first)
                hints.sort((a, b) => b.priority - a.priority);

                return hints.length > 0 ? hints[0] : null;
            }

            getHintDescription(card, srcCol, destCol, destColumn) {
                const cardName = `${card.rank}${card.suit}`;
                if (destColumn.length === 0) {
                    return `Move ${cardName} to empty column ${destCol + 1}`;
                }
                const destCard = destColumn[destColumn.length - 1];
                return `Move ${cardName} onto ${destCard.rank}${destCard.suit}`;
            }

            showHint() {
                this.clearHint();

                const hint = this.findHint();

                if (!hint) {
                    // No valid moves - maybe suggest drawing
                    if (this.stock.length > 0) {
                        // Flash the stock pile
                        this.flashStock();
                    }
                    return;
                }

                this.currentHint = hint;

                // Highlight source cards
                const srcColumn = this.columns[hint.srcCol];
                for (let i = hint.srcRow; i < srcColumn.length; i++) {
                    srcColumn[i].highlighted = true;
                    srcColumn[i].highlightColor = 'rgba(76, 175, 80, 0.9)';
                }

                // Highlight destination
                const destColumn = this.columns[hint.destCol];
                if (destColumn.length > 0) {
                    const destCard = destColumn[destColumn.length - 1];
                    destCard.highlighted = true;
                    destCard.highlightColor = 'rgba(255, 193, 7, 0.9)';
                }

                // Emit hint particles at source
                const srcCard = srcColumn[hint.srcRow];
                for (let i = 0; i < 10; i++) {
                    this.particles.emit(
                        srcCard.x + this.cardWidth / 2,
                        srcCard.y + this.cardHeight / 2,
                        'hint'
                    );
                }

                // Auto-clear hint after 3 seconds
                this.hintTimeout = setTimeout(() => this.clearHint(), 3000);
            }

            flashStock() {
                // Visual feedback that player should draw
                let flashes = 0;
                const flashInterval = setInterval(() => {
                    flashes++;
                    // The stock will be highlighted in the draw method
                    this.stockHighlighted = flashes % 2 === 1;
                    if (flashes >= 6) {
                        clearInterval(flashInterval);
                        this.stockHighlighted = false;
                    }
                }, 200);
            }

            clearHint() {
                if (this.hintTimeout) {
                    clearTimeout(this.hintTimeout);
                    this.hintTimeout = null;
                }

                // Remove all highlights
                for (const column of this.columns) {
                    for (const card of column) {
                        card.highlighted = false;
                        card.highlightColor = null;
                    }
                }

                this.currentHint = null;
            }

            saveState() {
                const state = {
                    columns: this.columns.map(col => col.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    }))),
                    stock: this.stock.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    })),
                    completed: this.completed.length,
                    score: this.score
                };

                this.undoStack.push(JSON.stringify(state));
                if (this.undoStack.length > CONFIG.MAX_UNDO) {
                    this.undoStack.shift();
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;

                this.clearHint();
                const state = JSON.parse(this.undoStack.pop());

                this.columns = state.columns.map(col => col.map(data => {
                    const card = new Card(data.suit, data.rank);
                    card.faceUp = data.faceUp;
                    return card;
                }));

                this.stock = state.stock.map(data => {
                    const card = new Card(data.suit, data.rank);
                    card.faceUp = data.faceUp;
                    return card;
                });

                while (this.completed.length > state.completed) {
                    this.completed.pop();
                }

                this.score = state.score;
                this.updateScore();
                this.updateCardPositions();
                this.saveGame();
            }

            addScore(points) {
                this.score += points;
                this.updateScore();
            }

            updateScore() {
                document.getElementById('scoreValue').textContent = this.score;
            }

            win() {
                const interval = setInterval(() => {
                    for (let i = 0; i < 15; i++) {
                        this.particles.emit(
                            Math.random() * this.canvas.width,
                            this.canvas.height + 50,
                            'confetti'
                        );
                    }
                }, 100);

                setTimeout(() => {
                    clearInterval(interval);
                    document.getElementById('finalScore').textContent = this.score;
                    document.getElementById('winScreen').style.display = 'flex';
                }, 3000);

                localStorage.removeItem('perfectSolitaireSave');
            }

            saveGame() {
                const state = {
                    columns: this.columns.map(col => col.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    }))),
                    stock: this.stock.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    })),
                    completed: this.completed.length,
                    score: this.score,
                    suitCount: this.suitCount
                };
                localStorage.setItem('perfectSolitaireSave', JSON.stringify(state));
            }

            loadGame() {
                const saved = localStorage.getItem('perfectSolitaireSave');
                if (!saved) return false;

                try {
                    const state = JSON.parse(saved);

                    this.suitCount = state.suitCount || 4;
                    document.querySelectorAll('.suit-btn').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.suits) === this.suitCount);
                    });

                    this.columns = state.columns.map(col => col.map(data => {
                        const card = new Card(data.suit, data.rank);
                        card.faceUp = data.faceUp;
                        return card;
                    }));

                    this.stock = state.stock.map(data => {
                        const card = new Card(data.suit, data.rank);
                        card.faceUp = data.faceUp;
                        return card;
                    });

                    this.completed = new Array(state.completed).fill([]);
                    this.score = state.score;
                    this.updateScore();
                    this.updateCardPositions();

                    return true;
                } catch (e) {
                    return false;
                }
            }

            drawStock() {
                const x = this.stockX;
                const y = this.stockY;

                // Draw stock pile background - vintage style
                this.ctx.fillStyle = this.stockHighlighted ? 'rgba(76, 175, 80, 0.4)' : 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.roundRect(x, y, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                this.ctx.fill();

                if (this.stockHighlighted) {
                    this.ctx.strokeStyle = '#4CAF50';
                    this.ctx.lineWidth = 3;
                    this.ctx.stroke();
                }

                // Draw stock count with vintage styling
                this.ctx.fillStyle = this.stock.length > 0 ? 'rgba(212, 168, 67, 0.6)' : 'rgba(255, 255, 255, 0.2)';
                this.ctx.font = 'bold 18px "Playfair Display", serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.stock.length, x + this.cardWidth / 2, y + this.cardHeight / 2 + 6);

                // Draw completed piles indicator
                for (let i = 0; i < this.completed.length; i++) {
                    const px = this.stockX + this.cardWidth + 20 + i * (this.cardWidth * 0.3);
                    const py = this.stockY;

                    this.ctx.fillStyle = 'rgba(212, 168, 67, 0.25)';
                    this.ctx.beginPath();
                    this.roundRect(px, py, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(212, 168, 67, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();

                    // Draw checkmark
                    this.ctx.fillStyle = 'rgba(212, 168, 67, 0.7)';
                    this.ctx.font = '24px serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('✓', px + this.cardWidth / 2, py + this.cardHeight / 2 + 8);
                }
            }

            roundRect(x, y, w, h, r) {
                this.ctx.moveTo(x + r, y);
                this.ctx.lineTo(x + w - r, y);
                this.ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                this.ctx.lineTo(x + w, y + h - r);
                this.ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.ctx.lineTo(x + r, y + h);
                this.ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                this.ctx.lineTo(x, y + r);
                this.ctx.quadraticCurveTo(x, y, x + r, y);
            }

            gameLoop() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw vintage felt texture
                const feltGradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height) / 1.5
                );
                feltGradient.addColorStop(0, '#1a4d1a');
                feltGradient.addColorStop(0.5, '#134013');
                feltGradient.addColorStop(1, '#0a280a');
                this.ctx.fillStyle = feltGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw column placeholders - vintage style
                for (let col = 0; col < 10; col++) {
                    const x = this.startX + col * (this.cardWidth + this.columnSpacing);
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.beginPath();
                    this.roundRect(x, this.startY, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                    this.ctx.fill();

                    // Subtle border
                    this.ctx.strokeStyle = 'rgba(212, 168, 67, 0.15)';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }

                // Draw stock area
                this.drawStock();

                // Collect all cards for z-sorting
                const allCards = [];

                for (const column of this.columns) {
                    for (const card of column) {
                        allCards.push(card);
                    }
                }

                for (const card of this.stock) {
                    allCards.push(card);
                }

                for (const card of this.draggedCards) {
                    allCards.push(card);
                }

                // Sort by z-index
                allCards.sort((a, b) => a.zIndex - b.zIndex);

                // Update and draw cards
                for (const card of allCards) {
                    card.update();
                    card.draw(this.ctx);
                }

                // Update and draw particles
                this.particles.update();
                this.particles.draw(this.ctx);

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start game
        new PerfectSolitaire();
    </script>
</body>
</html>
