<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Perfect Solitaire</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1a472a 0%, #0d2818 50%, #1a472a 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        /* Glassmorphism Controls */
        .controls {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
        }

        .glass-btn {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 10px 20px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .glass-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .glass-btn:active {
            transform: translateY(0);
        }

        .glass-btn.active {
            background: rgba(255, 215, 0, 0.3);
            border-color: rgba(255, 215, 0, 0.5);
        }

        .score-display {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px 20px;
            color: #ffd700;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .suit-selector {
            display: flex;
            gap: 5px;
        }

        .suit-btn {
            padding: 10px 15px;
            min-width: 45px;
        }

        /* Win Screen */
        #winScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }

        .trophy {
            font-size: 120px;
            animation: bounce 1s ease infinite;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .win-text {
            color: #ffd700;
            font-size: 48px;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            animation: pulse 1.5s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .win-score {
            color: white;
            font-size: 24px;
            margin-top: 10px;
        }

        .win-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 18px;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .glass-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
            .score-display {
                font-size: 14px;
                padding: 8px 12px;
            }
            .trophy {
                font-size: 80px;
            }
            .win-text {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div class="controls">
            <button class="glass-btn" id="newGameBtn">New Game</button>
            <button class="glass-btn" id="drawBtn">Draw</button>
            <button class="glass-btn" id="undoBtn">Undo</button>
            <div class="suit-selector">
                <button class="glass-btn suit-btn" data-suits="1">1</button>
                <button class="glass-btn suit-btn" data-suits="2">2</button>
                <button class="glass-btn suit-btn active" data-suits="4">4</button>
            </div>
            <div class="score-display">Score: <span id="scoreValue">0</span></div>
        </div>

        <div id="winScreen">
            <div class="trophy">üèÜ</div>
            <div class="win-text">YOU WIN!</div>
            <div class="win-score">Final Score: <span id="finalScore">0</span></div>
            <button class="glass-btn win-btn" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <script>
        // ============== CONFIGURATION ==============
        const CONFIG = {
            CARD_WIDTH: 70,
            CARD_HEIGHT: 100,
            CARD_RADIUS: 8,
            COLUMN_SPACING: 10,
            ROW_OFFSET: 25,
            STOCK_OFFSET: 3,
            MAX_PARTICLES: 500,
            GRAVITY: 0.5,
            FRICTION: 0.95,
            LERP_SPEED: 0.15,
            MAX_UNDO: 5,
            SUITS: ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'],
            SUIT_COLORS: { '‚ô†': '#1a1a2e', '‚ô•': '#c41e3a', '‚ô¶': '#c41e3a', '‚ô£': '#1a1a2e' },
            RANKS: ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'],
            RANK_VALUES: { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13 }
        };

        // ============== PARTICLE SYSTEM ==============
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1;
                this.decay = 0.02 + Math.random() * 0.02;

                if (type === 'trail') {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.size = 3 + Math.random() * 3;
                    this.color = `hsla(${200 + Math.random() * 40}, 80%, 60%, `;
                } else if (type === 'spark') {
                    this.vx = (Math.random() - 0.5) * 8;
                    this.vy = -Math.random() * 10 - 5;
                    this.size = 2 + Math.random() * 4;
                    this.color = `hsla(${45 + Math.random() * 15}, 100%, 50%, `;
                } else if (type === 'confetti') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = -Math.random() * 15 - 5;
                    this.size = 5 + Math.random() * 5;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.3;
                    this.color = `hsla(${Math.random() * 360}, 100%, 60%, `;
                    this.decay = 0.005 + Math.random() * 0.005;
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += CONFIG.GRAVITY * 0.3;
                this.vx *= 0.99;
                this.life -= this.decay;
                if (this.type === 'confetti') {
                    this.rotation += this.rotationSpeed;
                }
                return this.life > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color + this.life + ')';

                if (this.type === 'confetti') {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.fillRect(-this.size/2, -this.size/4, this.size, this.size/2);
                } else {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
        }

        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(x, y, type, count = 1) {
                for (let i = 0; i < count; i++) {
                    if (this.particles.length < CONFIG.MAX_PARTICLES) {
                        this.particles.push(new Particle(x, y, type));
                    }
                }
            }

            update() {
                this.particles = this.particles.filter(p => p.update());
            }

            draw(ctx) {
                this.particles.forEach(p => p.draw(ctx));
            }

            clear() {
                this.particles = [];
            }
        }

        // ============== CARD CLASS ==============
        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.value = CONFIG.RANK_VALUES[rank];
                this.faceUp = false;
                this.x = 0;
                this.y = 0;
                this.targetX = 0;
                this.targetY = 0;
                this.vx = 0;
                this.vy = 0;
                this.width = CONFIG.CARD_WIDTH;
                this.height = CONFIG.CARD_HEIGHT;
                this.dragging = false;
                this.hovered = false;
                this.zIndex = 0;
            }

            get color() {
                return CONFIG.SUIT_COLORS[this.suit];
            }

            update() {
                if (!this.dragging) {
                    // Verlet integration with lerp smoothing
                    this.vx += (this.targetX - this.x) * CONFIG.LERP_SPEED;
                    this.vy += (this.targetY - this.y) * CONFIG.LERP_SPEED;
                    this.vx *= CONFIG.FRICTION;
                    this.vy *= CONFIG.FRICTION;
                    this.x += this.vx;
                    this.y += this.vy;
                }
            }

            draw(ctx) {
                ctx.save();

                // Shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = this.dragging ? 20 : 10;
                ctx.shadowOffsetX = this.dragging ? 8 : 3;
                ctx.shadowOffsetY = this.dragging ? 8 : 3;

                // Card body
                ctx.beginPath();
                this.roundRect(ctx, this.x, this.y, this.width, this.height, CONFIG.CARD_RADIUS);

                if (this.faceUp) {
                    // White card face
                    const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#f0f0f0');
                    ctx.fillStyle = gradient;
                    ctx.fill();

                    // Hover glow
                    if (this.hovered && !this.dragging) {
                        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    ctx.shadowColor = 'transparent';

                    // Border
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Draw suit and rank
                    ctx.fillStyle = this.color;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(this.rank, this.x + 5, this.y + 18);
                    ctx.fillText(this.suit, this.x + 5, this.y + 35);

                    // Center suit
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.suit, this.x + this.width/2, this.y + this.height/2 + 10);

                    // Bottom right (inverted)
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(this.rank, this.x + this.width - 5, this.y + this.height - 8);
                    ctx.fillText(this.suit, this.x + this.width - 5, this.y + this.height - 23);
                } else {
                    // Card back with pattern
                    const backGradient = ctx.createLinearGradient(this.x, this.y, this.x + this.width, this.y + this.height);
                    backGradient.addColorStop(0, '#1e3a5f');
                    backGradient.addColorStop(0.5, '#2d5a87');
                    backGradient.addColorStop(1, '#1e3a5f');
                    ctx.fillStyle = backGradient;
                    ctx.fill();

                    ctx.strokeStyle = '#0f2540';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.shadowColor = 'transparent';

                    // Pattern
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    const padding = 8;
                    for (let i = 0; i < 6; i++) {
                        const offset = i * 8;
                        ctx.beginPath();
                        ctx.moveTo(this.x + padding + offset, this.y + padding);
                        ctx.lineTo(this.x + padding, this.y + padding + offset);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width - padding - offset, this.y + this.height - padding);
                        ctx.lineTo(this.x + this.width - padding, this.y + this.height - padding - offset);
                        ctx.stroke();
                    }

                    // Center diamond
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.beginPath();
                    const cx = this.x + this.width/2;
                    const cy = this.y + this.height/2;
                    ctx.moveTo(cx, cy - 15);
                    ctx.lineTo(cx + 10, cy);
                    ctx.lineTo(cx, cy + 15);
                    ctx.lineTo(cx - 10, cy);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            roundRect(ctx, x, y, w, h, r) {
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
            }

            contains(px, py) {
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            setTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
            }

            snapTo(x, y) {
                this.x = this.targetX = x;
                this.y = this.targetY = y;
                this.vx = 0;
                this.vy = 0;
            }
        }

        // ============== GAME CLASS ==============
        class PerfectSolitaire {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = new ParticleSystem();

                this.columns = [];
                this.stock = [];
                this.completed = [];
                this.draggedCards = [];
                this.dragStartColumn = -1;
                this.dragStartIndex = -1;
                this.dragOffsetX = 0;
                this.dragOffsetY = 0;

                this.score = 0;
                this.suitCount = 4;
                this.undoStack = [];
                this.hoveredCard = null;

                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.mouseVX = 0;
                this.mouseVY = 0;

                this.setupCanvas();
                this.setupEventListeners();
                this.loadGame() || this.newGame();
                this.gameLoop();
            }

            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.calculateLayout();
                };
                window.addEventListener('resize', resize);
                resize();
            }

            calculateLayout() {
                const totalWidth = 10 * CONFIG.CARD_WIDTH + 9 * CONFIG.COLUMN_SPACING;
                const availableWidth = this.canvas.width - 40;
                const scale = Math.min(1, availableWidth / totalWidth);

                this.cardWidth = CONFIG.CARD_WIDTH * scale;
                this.cardHeight = CONFIG.CARD_HEIGHT * scale;
                this.columnSpacing = CONFIG.COLUMN_SPACING * scale;
                this.rowOffset = CONFIG.ROW_OFFSET * scale;

                this.startX = (this.canvas.width - (10 * this.cardWidth + 9 * this.columnSpacing)) / 2;
                this.startY = 80;
                this.stockX = this.startX;
                this.stockY = this.canvas.height - this.cardHeight - 20;

                // Update all card positions
                this.updateCardPositions();
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerDown(e.clientX, e.clientY));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e.clientX, e.clientY));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerUp(e.clientX, e.clientY));
                this.canvas.addEventListener('mouseleave', () => this.handlePointerUp(0, 0));

                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerDown(touch.clientX, touch.clientY);
                }, { passive: false });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handlePointerMove(touch.clientX, touch.clientY);
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handlePointerUp(this.lastMouseX, this.lastMouseY);
                }, { passive: false });

                // Buttons
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('drawBtn').addEventListener('click', () => this.drawFromStock());
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    document.getElementById('winScreen').style.display = 'none';
                    this.newGame();
                });

                // Suit buttons
                document.querySelectorAll('.suit-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.suit-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.suitCount = parseInt(btn.dataset.suits);
                        this.newGame();
                    });
                });
            }

            createDeck() {
                const deck = [];
                const decksNeeded = 2;
                const suitsToUse = CONFIG.SUITS.slice(0, this.suitCount);

                for (let d = 0; d < decksNeeded; d++) {
                    for (const suit of suitsToUse) {
                        const copies = Math.ceil(4 / this.suitCount);
                        for (let c = 0; c < copies; c++) {
                            for (const rank of CONFIG.RANKS) {
                                deck.push(new Card(suit, rank));
                            }
                        }
                    }
                }

                // Shuffle to exactly 104 cards
                while (deck.length > 104) deck.pop();
                while (deck.length < 104) {
                    const suit = suitsToUse[Math.floor(Math.random() * suitsToUse.length)];
                    const rank = CONFIG.RANKS[Math.floor(Math.random() * CONFIG.RANKS.length)];
                    deck.push(new Card(suit, rank));
                }

                // Fisher-Yates shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                return deck;
            }

            newGame() {
                this.particles.clear();
                this.score = 0;
                this.undoStack = [];
                this.completed = [];
                this.draggedCards = [];
                this.updateScore();

                const deck = this.createDeck();
                this.columns = [];

                // 10 columns: 4 with 6 cards, 6 with 5 cards
                let cardIndex = 0;
                for (let col = 0; col < 10; col++) {
                    const columnCards = [];
                    const cardCount = col < 4 ? 6 : 5;

                    for (let row = 0; row < cardCount; row++) {
                        const card = deck[cardIndex++];
                        card.faceUp = (row === cardCount - 1);
                        columnCards.push(card);
                    }
                    this.columns.push(columnCards);
                }

                // Remaining 50 cards go to stock (104 - 54 = 50)
                this.stock = deck.slice(cardIndex);
                this.stock.forEach(card => card.faceUp = false);

                this.updateCardPositions();
                this.saveGame();
            }

            updateCardPositions() {
                // Update column cards
                for (let col = 0; col < this.columns.length; col++) {
                    const column = this.columns[col];
                    for (let row = 0; row < column.length; row++) {
                        const card = column[row];
                        if (!card.dragging) {
                            const x = this.startX + col * (this.cardWidth + this.columnSpacing);
                            const y = this.startY + row * this.rowOffset;
                            card.setTarget(x, y);
                            card.width = this.cardWidth;
                            card.height = this.cardHeight;
                            card.zIndex = row;
                        }
                    }
                }

                // Update stock
                for (let i = 0; i < this.stock.length; i++) {
                    const card = this.stock[i];
                    card.setTarget(this.stockX + Math.min(i, 5) * CONFIG.STOCK_OFFSET, this.stockY);
                    card.width = this.cardWidth;
                    card.height = this.cardHeight;
                    card.zIndex = i;
                }
            }

            handlePointerDown(x, y) {
                // Check stock click
                if (this.stock.length > 0) {
                    const topStock = this.stock[this.stock.length - 1];
                    if (topStock.contains(x, y)) {
                        this.drawFromStock();
                        return;
                    }
                }

                // Check columns
                for (let col = this.columns.length - 1; col >= 0; col--) {
                    const column = this.columns[col];
                    for (let row = column.length - 1; row >= 0; row--) {
                        const card = column[row];
                        if (card.faceUp && card.contains(x, y)) {
                            // Check if we can drag this stack
                            if (this.canDragStack(col, row)) {
                                this.startDrag(col, row, x, y);
                                return;
                            }
                        }
                    }
                }
            }

            canDragStack(col, startRow) {
                const column = this.columns[col];
                // Check if cards form a descending sequence
                for (let i = startRow; i < column.length - 1; i++) {
                    if (!column[i].faceUp || column[i].value !== column[i + 1].value + 1) {
                        return false;
                    }
                }
                return true;
            }

            startDrag(col, row, x, y) {
                this.dragStartColumn = col;
                this.dragStartIndex = row;

                const column = this.columns[col];
                this.draggedCards = column.splice(row);

                const firstCard = this.draggedCards[0];
                this.dragOffsetX = x - firstCard.x;
                this.dragOffsetY = y - firstCard.y;

                this.draggedCards.forEach((card, i) => {
                    card.dragging = true;
                    card.zIndex = 1000 + i;
                });
            }

            handlePointerMove(x, y) {
                // Track velocity
                this.mouseVX = x - this.lastMouseX;
                this.mouseVY = y - this.lastMouseY;
                this.lastMouseX = x;
                this.lastMouseY = y;

                if (this.draggedCards.length > 0) {
                    // Emit trail particles
                    if (Math.random() > 0.5) {
                        this.particles.emit(x, y, 'trail', 1);
                    }

                    // Update dragged card positions
                    this.draggedCards.forEach((card, i) => {
                        card.x = x - this.dragOffsetX;
                        card.y = y - this.dragOffsetY + i * this.rowOffset;
                    });
                } else {
                    // Handle hover
                    this.hoveredCard = null;
                    for (const column of this.columns) {
                        for (const card of column) {
                            card.hovered = false;
                            if (card.faceUp && card.contains(x, y)) {
                                card.hovered = true;
                                this.hoveredCard = card;
                            }
                        }
                    }
                }
            }

            handlePointerUp(x, y) {
                if (this.draggedCards.length === 0) return;

                // Apply throw velocity
                this.draggedCards.forEach(card => {
                    card.vx = this.mouseVX * 0.5;
                    card.vy = this.mouseVY * 0.5;
                    card.dragging = false;
                });

                // Find target column
                let targetCol = -1;
                let validMove = false;

                const firstDragged = this.draggedCards[0];

                for (let col = 0; col < 10; col++) {
                    const colX = this.startX + col * (this.cardWidth + this.columnSpacing);
                    if (x >= colX && x <= colX + this.cardWidth) {
                        targetCol = col;
                        break;
                    }
                }

                if (targetCol >= 0 && targetCol !== this.dragStartColumn) {
                    const targetColumn = this.columns[targetCol];

                    if (targetColumn.length === 0) {
                        // Any card can go to empty column
                        validMove = true;
                    } else {
                        const topCard = targetColumn[targetColumn.length - 1];
                        // Any-suit descending moves
                        if (topCard.faceUp && topCard.value === firstDragged.value + 1) {
                            validMove = true;
                        }
                    }
                }

                if (validMove) {
                    // Save state for undo
                    this.saveState();

                    // Move cards to target
                    this.columns[targetCol].push(...this.draggedCards);

                    // Reveal top card in source column
                    this.revealTopCard(this.dragStartColumn);

                    // Award points
                    this.addScore(this.draggedCards.length * 5);

                    // Check for completed sequence
                    this.checkSequenceComplete(targetCol);
                } else {
                    // Return cards to source
                    this.columns[this.dragStartColumn].push(...this.draggedCards);
                }

                this.draggedCards = [];
                this.updateCardPositions();
                this.saveGame();
            }

            revealTopCard(col) {
                const column = this.columns[col];
                if (column.length > 0 && !column[column.length - 1].faceUp) {
                    column[column.length - 1].faceUp = true;
                    this.addScore(10);
                }
            }

            checkSequenceComplete(col) {
                const column = this.columns[col];
                if (column.length < 13) return;

                // Check for same-suit K-A sequence
                const lastIndex = column.length - 1;
                if (column[lastIndex].value !== 1) return; // Must end with Ace

                const suit = column[lastIndex].suit;
                let valid = true;

                for (let i = 0; i < 13; i++) {
                    const card = column[lastIndex - i];
                    if (!card.faceUp || card.suit !== suit || card.value !== i + 1) {
                        valid = false;
                        break;
                    }
                }

                if (valid) {
                    // Remove sequence
                    const removed = column.splice(column.length - 13);
                    this.completed.push(removed);

                    // Emit gold sparks
                    const centerX = this.startX + col * (this.cardWidth + this.columnSpacing) + this.cardWidth / 2;
                    const centerY = this.startY + (column.length + 6) * this.rowOffset;
                    for (let i = 0; i < 50; i++) {
                        this.particles.emit(centerX, centerY, 'spark', 1);
                    }

                    this.addScore(100);
                    this.revealTopCard(col);

                    // Check win
                    if (this.completed.length === 8) {
                        this.win();
                    }
                }
            }

            drawFromStock() {
                // Block if any column is empty
                const hasEmpty = this.columns.some(col => col.length === 0);
                if (hasEmpty) {
                    // Visual feedback - shake empty columns
                    return;
                }

                if (this.stock.length === 0) return;

                this.saveState();

                // Deal one card to each column
                for (let col = 0; col < 10 && this.stock.length > 0; col++) {
                    const card = this.stock.pop();
                    card.faceUp = true;
                    this.columns[col].push(card);
                }

                this.updateCardPositions();
                this.saveGame();
            }

            saveState() {
                const state = {
                    columns: this.columns.map(col => col.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    }))),
                    stock: this.stock.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    })),
                    completed: this.completed.length,
                    score: this.score
                };

                this.undoStack.push(JSON.stringify(state));
                if (this.undoStack.length > CONFIG.MAX_UNDO) {
                    this.undoStack.shift();
                }
            }

            undo() {
                if (this.undoStack.length === 0) return;

                const state = JSON.parse(this.undoStack.pop());

                this.columns = state.columns.map(col => col.map(data => {
                    const card = new Card(data.suit, data.rank);
                    card.faceUp = data.faceUp;
                    return card;
                }));

                this.stock = state.stock.map(data => {
                    const card = new Card(data.suit, data.rank);
                    card.faceUp = data.faceUp;
                    return card;
                });

                // Adjust completed sequences
                while (this.completed.length > state.completed) {
                    this.completed.pop();
                }

                this.score = state.score;
                this.updateScore();
                this.updateCardPositions();
                this.saveGame();
            }

            addScore(points) {
                this.score += points;
                this.updateScore();
            }

            updateScore() {
                document.getElementById('scoreValue').textContent = this.score;
            }

            win() {
                // Rainbow confetti!
                const interval = setInterval(() => {
                    for (let i = 0; i < 20; i++) {
                        this.particles.emit(
                            Math.random() * this.canvas.width,
                            this.canvas.height + 50,
                            'confetti'
                        );
                    }
                }, 100);

                setTimeout(() => {
                    clearInterval(interval);
                    document.getElementById('finalScore').textContent = this.score;
                    document.getElementById('winScreen').style.display = 'flex';
                }, 3000);

                localStorage.removeItem('perfectSolitaireSave');
            }

            saveGame() {
                const state = {
                    columns: this.columns.map(col => col.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    }))),
                    stock: this.stock.map(card => ({
                        suit: card.suit,
                        rank: card.rank,
                        faceUp: card.faceUp
                    })),
                    completed: this.completed.length,
                    score: this.score,
                    suitCount: this.suitCount
                };
                localStorage.setItem('perfectSolitaireSave', JSON.stringify(state));
            }

            loadGame() {
                const saved = localStorage.getItem('perfectSolitaireSave');
                if (!saved) return false;

                try {
                    const state = JSON.parse(saved);

                    this.suitCount = state.suitCount || 4;
                    document.querySelectorAll('.suit-btn').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.suits) === this.suitCount);
                    });

                    this.columns = state.columns.map(col => col.map(data => {
                        const card = new Card(data.suit, data.rank);
                        card.faceUp = data.faceUp;
                        return card;
                    }));

                    this.stock = state.stock.map(data => {
                        const card = new Card(data.suit, data.rank);
                        card.faceUp = data.faceUp;
                        return card;
                    });

                    this.completed = new Array(state.completed).fill([]);
                    this.score = state.score;
                    this.updateScore();
                    this.updateCardPositions();

                    return true;
                } catch (e) {
                    return false;
                }
            }

            drawStock() {
                const x = this.stockX;
                const y = this.stockY;

                // Draw stock pile background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.beginPath();
                this.roundRect(x, y, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                this.ctx.fill();

                // Draw stock count
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.stock.length, x + this.cardWidth / 2, y + this.cardHeight / 2 + 7);

                // Draw completed piles
                for (let i = 0; i < this.completed.length; i++) {
                    const px = this.stockX + this.cardWidth + 20 + i * (this.cardWidth * 0.3);
                    const py = this.stockY;

                    this.ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    this.ctx.beginPath();
                    this.roundRect(px, py, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }

            roundRect(x, y, w, h, r) {
                this.ctx.moveTo(x + r, y);
                this.ctx.lineTo(x + w - r, y);
                this.ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                this.ctx.lineTo(x + w, y + h - r);
                this.ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.ctx.lineTo(x + r, y + h);
                this.ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                this.ctx.lineTo(x, y + r);
                this.ctx.quadraticCurveTo(x, y, x + r, y);
            }

            gameLoop() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw felt texture
                this.ctx.fillStyle = '#1a472a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw column placeholders
                for (let col = 0; col < 10; col++) {
                    const x = this.startX + col * (this.cardWidth + this.columnSpacing);
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.beginPath();
                    this.roundRect(x, this.startY, this.cardWidth, this.cardHeight, CONFIG.CARD_RADIUS);
                    this.ctx.fill();
                }

                // Draw stock area
                this.drawStock();

                // Collect all cards for z-sorting
                const allCards = [];

                for (const column of this.columns) {
                    for (const card of column) {
                        allCards.push(card);
                    }
                }

                for (const card of this.stock) {
                    allCards.push(card);
                }

                for (const card of this.draggedCards) {
                    allCards.push(card);
                }

                // Sort by z-index
                allCards.sort((a, b) => a.zIndex - b.zIndex);

                // Update and draw cards
                for (const card of allCards) {
                    card.update();
                    card.draw(this.ctx);
                }

                // Update and draw particles
                this.particles.update();
                this.particles.draw(this.ctx);

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Start game
        new PerfectSolitaire();
    </script>
</body>
</html>
